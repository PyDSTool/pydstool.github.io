<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>BoundsSafetyn</title></head>

<body  lang="en" dir="ltr">
<div id="page" lang="en" dir="ltr">

<h1>Bounds safety</h1>

<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><span class="anchor" id="line-4"></span><span class="anchor" id="line-5"></span><p class="line867"><div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol><li>
<a href="#Introduction">Introduction</a></li><li>
<a href="#The_numerical_interval_class">The numerical interval class</a><ol><li>
<a href="#Rounding_error_at_endpoints">Rounding error at endpoints</a></li></ol></li><li>
<a href="#Behaviour_at_interval_endpoints">Behaviour at interval endpoints</a></li><li>
<a href="#The_use_of_events_for_bounds_safety">The use of events for bounds safety</a></li><li>
<a href="#Strategy_for_efficiency">Strategy for efficiency</a></li></ol></div> <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><p class="line867"><hr /><p class="line874"> <span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line867">
<h1 id="Introduction">1. Introduction</h1>
<span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line874">PyDSTool supports the optional specification of bounds on variables and parameters. This is most useful when performing parameter and model estimation, but also provides a means to check the consistency of iterative processes as they run. <span class="anchor" id="line-12"></span><span class="anchor" id="line-13"></span><p class="line862">Bounds on variables are specified to a Generator (see <a href="./Generators.html">Generators</a>) using the <tt>xdomain</tt> key, while those on parameters use the <tt>pdomain</tt> key. Computed Trajectories or raw numeric intervals are also defined on a specific domain of validity. These domains may be semi- or bi-infinite (through the use of the IEEE 754 <tt>Inf</tt> special value). <span class="anchor" id="line-14"></span><span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span><p class="line867">
<h1 id="The_numerical_interval_class">2. The numerical interval class</h1>
<span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span><p class="line862">In <tt>Interval.py</tt> a class for representing numeric intervals is specified. This class is fundamental to PyDSTool in the specification of closed sets of real numbers or integers. (An extension to complex numbers is not presently planned, but would be an easy extension.) <span class="anchor" id="line-19"></span><span class="anchor" id="line-20"></span><p class="line867">
<h2 id="Rounding_error_at_endpoints">2.1. Rounding error at endpoints</h2>
<span class="anchor" id="line-21"></span><span class="anchor" id="line-22"></span><p class="line874">Interval checking at endpoints can suffer from numerical rounding errors that may incorrectly indicate that a value is inside or outside a given interval. This commonly occurs in floating point arithmetic involving numbers of greatly different magnitude. In practice the problem arises particularly in the use of hybrid systems when the determination of appropriate trajectory segment relies on a subtraction, where the result is then evaluated for interval containment. <span class="anchor" id="line-23"></span><span class="anchor" id="line-24"></span><p class="line862">To help counter this problem, the user may specify an <em>absolute</em> tolerance for interval specifications. Numerical errors of magnitude smaller than this tolerance will lead to the test value being <em>included</em> in the interval. For this to work well, it is recommended that all quantities in a user's model should be pre-scaled to be of "order 1" magnitude. (A relative tolerance may be implemented later, which would avoid this necessity.) <span class="anchor" id="line-25"></span>The default absolute tolerance is <tt>1e-14</tt>. <span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><span class="anchor" id="line-28"></span><p class="line867">
<h1 id="Behaviour_at_interval_endpoints">3. Behaviour at interval endpoints</h1>
<span class="anchor" id="line-29"></span><span class="anchor" id="line-30"></span><p class="line862">The <tt>checklevel</tt> parameter is used by Models, Generators, and Trajectory objects to determine behaviour when computations, comparisons, or trajectory lookups are evaluated within the absolute tolerance of an endpoint of the relevant interval.  This case is known as an <tt>uncertain</tt> evaluation, in contrast to those evaluations outside of this tolerance -- either <tt>contained</tt> or <tt>notcontained</tt>. <span class="anchor" id="line-31"></span><span class="anchor" id="line-32"></span><ul><li>0: no intelligent bounds checking, just evaluate on the expectation that the bounds restriction is strictly met (may cause exception if this fails) -- equivalent to absolute tolerance = 0. <span class="anchor" id="line-33"></span></li><li><p class="line862">1: <strong>ignore</strong> on <tt>uncertain</tt> (treat as <tt>contained</tt>), <strong>error</strong> on <tt>notcontained</tt>. <span class="anchor" id="line-34"></span></li><li><p class="line862">2: <strong>warn</strong> on <tt>uncertain</tt> (treat as <tt>contained</tt>), <strong>error</strong> on <tt>notcontained</tt> (<em>default</em>). <span class="anchor" id="line-35"></span><span class="anchor" id="line-36"></span></li></ul><p class="line862">Here, the flagging of a warning will consist of a record being kept in the Model, Generator, or Trajectory in the <tt>warnings</tt> attribute (usually read by a <tt>showWarnings</tt> method call, and cleared with <tt>clearWarnings</tt>). An error will consist of a <tt>PyDSTool_BoundsError</tt> or <tt>ValueError</tt> exception being raised. <span class="anchor" id="line-37"></span><span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><p class="line867">
<h1 id="The_use_of_events_for_bounds_safety">4. The use of events for bounds safety</h1>
<span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><p class="line862">By default, models constructed and compiled using the Model<tt class="backtick"></tt>Constructor classes come with a set of dormant (initially inactive) events that correspond to domain-crossing detectors. If variable domains were specified, these events can be made active so that bounds checking is used by ODE integrators, etc. This is a useful tool in the implementation of "non-negativity preserving" algorithms. <span class="anchor" id="line-42"></span><span class="anchor" id="line-43"></span><p class="line862">The occurrence of bounds errors can be trapped and used to change vector field in a hybrid system. Alternatively, these events can be used to efficiently stop computations that search initial condition or parameter spaces using expensive loops, and allow them to try another value. This feature is used in PyDSTool's parameter estimation class in the file <tt>ParamEst.py</tt>. <span class="anchor" id="line-44"></span><span class="anchor" id="line-45"></span><p class="line867">
<h1 id="Strategy_for_efficiency">5. Strategy for efficiency</h1>
<span class="anchor" id="line-46"></span><span class="anchor" id="line-47"></span><p class="line874">The activation of many events for bounds checking can incur a signifcant computational cost during simulation. The use of trajectory domain checks during lookup calls also incurs some cost. Therefore, a recommended strategy is to retain bounds checking when testing new models, or during parameter searches that may go "out of bounds", with a view to establishing a "safe working domain" in which bounds-checking can be switched off for maximum efficiency. <span class="anchor" id="line-48"></span><span class="anchor" id="bottom"></span></div>

<div id="pagebottom"></div>
</div>
</body>
</html>

