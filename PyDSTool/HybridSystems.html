<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head><title>Hybrid dynamical systems in PyDSTool</title>
</head>

<body  lang="en" dir="ltr">

<h1>Models as hybrid dynamical systems</h1>

<div class="table-of-contents"><p class="table-of-contents-heading">Contents<ol>
  <li>
<a href="#Overview">Overview of hybrid dynamical systems</a></li>
  <li>
<a href="#The_elements_of_a_hybrid_system">The elements of a hybrid system</a><ol><li>
<a href="#Global_and_local_time">Global and local time</a></li><li>
<a href="#Warning.21">Warning!</a></li><li>
  <a href="#More_information_to_come_...">More information to come ...</a></li>
</ol>
  <li><a href="#Interfacing_with_the_Model_class">Interfacing with the Model class</a>
    <ol>
      <li><a href="#Trajectories">Trajectories</a></li>
      <li><a href="#Important_model_methods">Important model methods</a></li>
    </ol>
  </li>  
  <li>
    <a href="#Determining_the_initial_Generator">Determining the initial Generator</a><ol><li>
      <a href="#Example">Example</a></li><li>
    <a href="#Some_event_consistency_checking_comes_for_free">Some event consistency checking comes for free</a></li></ol></li><li>
<a href="#Hybrid_systems_with_only_one_vector_field">Hybrid systems with only one vector field</a></li><li>
<a href="#Using_hybrid_systems_to_mix_maps.2C_preset_trajectories.2C_and_ODEs">Using hybrid systems to mix maps, preset trajectories, and ODEs</a><ol><li>
<a href="#Using_hybrid_systems_to_implement_discrete_delays">Using hybrid systems to implement discrete delays</a></li></ol></li><li>
<a href="#Using_hybrid_systems_to_represent_numerically-computed_maps">Using hybrid systems to represent numerically-computed maps</a></li></ol></div> 
</div>

<hr>

<h1 id="Overview">1. Overview of hybrid dynamical systems</h1>


<p class="line862">On this page we describe the use of the <tt>HybridModel</tt> class to represent  <em>hybrid dynamical systems</em>, that is, dynamical systems with smooth flows that are punctuated by discrete events (optionally undergoing discrete mappings of state at these events). The vector fields either side of an event may have different dimensions. Other uses for the Model class are found on the basic <a href="./Model.html">Model</a> page. A summary of the Model <strong>aggregation hierarchy</strong> (containment of other classes) is shown in the following figures:

<center>
  <table width="900" border="1">
    <tr>
      <td width="430"><img src="images/NonHybridModel.jpg" width="370" alt="NonHybridModel-agg"></td>
      <td width="52">&nbsp;</td>
      <td width="396"><img src="images/HybridModel.jpg" width="380" alt="HybridModel-agg"></td>
    </tr>
  </table>
</center> </p>

<p>iMI (eMI) means internal (external, respectively) <a href="./ModelInterface.html">Model Interface</a>, while the subscripts indicate that there can be one or more of each. Parentheses indicate optional attributes. For instance, the Feature and Metric classes are used optionally in external MIs, which are used optionally for global consistency control during hybrid trajectory calculations.</p>

<p>While other simulation environments provide an &quot;if..then&quot; statement or similar to support discontinuities in a vector field, we reserve that statement for use in discrete-time systems and then only for simple conditions. A more flexible and powerful way to specify discontinuities is given here, involving the ModelInterface classes, although there is some greater overhead involved in setting up the syntax. Through higher level specifications we hope to simplify this syntax in the future. One example of this is given by the import utility for <a href="http://www.nineml.org">NineML</a> model specifications of neural models (see the <a href="Tutorial/Tutorial_NineML.html">tutorial page</a>).</p>

<p class="line862">The focus of PyDSTool is on applications in the continuous domain, both in time and state. As a result, the approach taken to hybrid systems differs from that in many discrete event-based simulators such as <a class="http" href="http://simpy.sourceforge.net/">SimPy</a>. We effectively treat the continuous parts of trajectories more <em>fundamentally</em> than the discrete events that may switch between different vector fields or map system states instantaneously. PyDSTool is not an efficient general-purpose discrete event simulator (both in terms of computation and specification) if the main focus of the model's application is not continuous trajectories such as those defined by ODEs. </p>

<h1 id="The_elements_of_a_hybrid_system">2. The elements of a hybrid system</h1>

<p class="line874">There are three essential elements to a hybrid system model in PyDSTool: Generators, events, and transition rules between the Generators that are applied on occurrence of the events. The specification of an initial state condition must uniquely determine which Generator should be used to begin determining a trajectory. This is done by evaluation of the associated events for the system at the initial condition. A terminal <a href="./Events.html">event</a> may occur that stops the trajectory generation. At this point the transition rules for the stopped Generator are consulted, and a new Generator is chosen by applying those rules to the final state condition. The final state may also be mapped to a new value before becoming the initial condition for the next Generator.</p>

<h2 id="Global_and_local_time">2.1. Global and local time</h2>
<span class="anchor" id="line-26"></span><span class="anchor" id="line-27"></span><p class="line862">When used as a complete model in its own right, all references to time in a Generator object are to the absolute ("global") time. However, when embedded in a <tt>Model</tt> object as a hybrid system, the concept of absolute and relative ("local") time may become distinct for certain purposes. A Generator object has an attribute <tt>globalt0</tt> for use by a Model object for these purposes. The primary reason that a Generator object is set up this way is when it is re-used as a trajectory segment as part of a hybrid model. <span class="anchor" id="line-28"></span><span class="anchor" id="line-29"></span><p class="line862">A Generator trajectory may represent a stereotypical behaviour that is repeated often in the dynamics of a hybrid model. Rather than re-computing the same trajectory for different absolute time intervals, an independently existing trajectory whose time domain is stated in local time is more easily re-used. To commit a copy of such a Generator to a particular absolute time interval in a hybrid model, the <tt>globalt0</tt> is merely set appropriately. The Model class makes the handling of absolute time transparent to the end-user, and knows how to adjust queries in absolute time to the relative time of an appropriate consituent trajectory segment. <span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span><p class="line862">The built-in auxiliary function <tt>globalindepvar</tt> provides access to a hybrid system's absolute ("global") value of the independent variable (usually time) from within an individual Generator. More information about this function is provided on the page <a href="./UserDocumentation.html">UserDocumentation</a>. </p>

<h2 id="Warning.21">2.2. Warnings!</h2>
<span class="anchor" id="line-35"></span><span class="anchor" id="line-36"></span>
<p class="line874">1) In defining the events and transition rules of a hybrid system it is possible to specify to PyDSTool a Generator that can be entered with an initial state that violates one or more of the Generator's terminal event conditions. These conditions are (currently) not checked at initialization, and so trajectory determination will continue, possibly leading to errors.


<p class="line874">2) Don't try to create hybrid ODE models using &quot;if...then&quot; statements. The integrators can fail when their right-hand side functions change discontinuously, as their internal error detection diagnostics are not designed for such changes. This is particularly likely if vector field for one of the variables suddenly changes direction as a result of the discontinuity.
<h1 id="Interfacing_with_the_Model_class">3. Interfacing with the Model class</h1>

<p class="line874">A model instance holds information that determines which Generator is used to calculate a trajectory segment, given the initial state. When a terminal event occurs during the calculation, the model uses a rule to determine which Generator to use next.

<h2 id="Trajectories">3.1. Hybrid system Trajectories</h2>

<p class="line862">Hybrid trajectories are stored inside the Model object they are associated with. Hybrid trajectories can be accessed much the same way as regular trajectory objects when treated as continuous curves. However, hybrid trajectories can also be treated as discrete mappings, from one "terminal event" to the next. To access a hybrid trajectory this way, we call the Model instance that contains it with the additional option 'asmap=True': <span class="anchor" id="line-56"></span><tt>my_model(&lt;trajname&gt;,&nbsp;&lt;integer&gt;,&nbsp;asmap=True)</tt>, <span class="anchor" id="line-57"></span>where the integer represents the number of the partitions to access. These integers may range from 0 to the number of partitions minus one. The number of partitions can be found by calling <span class="anchor" id="line-58"></span><tt>my_model.numPartitions(&lt;trajname&gt;)</tt>. <span class="anchor" id="line-59"></span><span class="anchor" id="line-60"></span><p class="line874">In a Model object, alongside the hybrid trajectory is information about the event parameters used during its calculation. In fact, there is an object containing various types of information about the trajectory, referenced as <span class="anchor" id="line-61"></span><tt>my_model.trajectories[&lt;traj_name&gt;]</tt>. <span class="anchor" id="line-62"></span>The event parameters are stored in a copy of the <tt>EventStruct</tt> object associated with each Generator used to create the hybrid trajectory in a dictionary attribute 'genEventStructs', accessed in the following way: <span class="anchor" id="line-63"></span><tt>my_model.trajectories[&lt;traj_name&gt;].genEventStructs[&lt;gen_name&gt;]</tt>. <span class="anchor" id="line-64"></span>

<h2 id="Important_model_methods">3.2. Important model methods</h2>

<p class="line862">See <a href="./Model.html#Important_model_methods">Models</a>.</p>

<h1 id="Determining_the_initial_Generator">4. Determining the initial Generator</h1>
<span class="anchor" id="line-103"></span><span class="anchor" id="line-104"></span><p class="line874">The approach taken in PyDSTool is that when a hybrid system is declared in which there is more than one vector field (i.e. more than one Generator), the hybrid solver must be able to automatically determine the correct Generator to use at the initial time for a given initial condition (IC). There need to be a set of self-consistent conditions placed on the initial state in order for the hybrid solver to determine which Generator to use at the starting time -- the user cannot explicitly name the initial Generator.  <span class="anchor" id="line-105"></span><span class="anchor" id="line-106"></span><p class="line862">Primarily, these conditions come from evaluating the terminal events associated with each Generator at the initial condition provided. The <tt>Model</tt> class will only evaluate the terminal events that have been set <em>active</em> (which is their default state if the user has not specified). The reason the user is not allowed to suggest an initial Generator is twofold. Firstly, the user might not specify a Generator that is consistent with the way the terminal events partition the state space. Therefore, regardless of how the initial Generator is determined, this consistency check ought to be made. Secondly, if this consistency check remains incomplete because the initial Generator choice is under-specified, then we are at the mercy of human input to initiate hybrid solving. How will the hybrid solver know what to do if it is running unsupervised, and the initial condition is generated automatically by an algorithm that doesn't know about the hybrid system definition that will be using that IC? Forcing the setup of the hybrid system to be logically self-consistent without the arbitrary input of a user to set the initial Generator guarantees some safety in running the hybrid solver unsupervised. <span class="anchor" id="line-107"></span><span class="anchor" id="line-108"></span><p class="line862">How does this problem arise in practice? For one thing, directionless threshold-crossing events (<tt>dircode=0</tt>) do not partition the state space in a way that helps to determine in which sub-domain an initial condition lies. Additionally, even for a set of events that all have a fixed direction of threshold crossing, the set still may not uniquely determine a sub-domain. This <span class="anchor" id="line-109"></span>may happen for several reasons: (1) because it is natural to place ICs right on an event surface for some Generator "G", leaving the eligibility of "G" indeterminate; (2) because it is most efficient to specify only <em>sufficient</em> conditions for termination of a trajectory computation with the current vector field: an exhaustive set of necessary and sufficient termination conditions would be required to guarantee that an IC is uniquely placed in a sub-domain of the state space; (3) even if all those conditions were listed, some terminal events are set to occur not when a function of the system state passes a threshold, but when a certain amount of time has elapsed. <span class="anchor" id="line-110"></span><span class="anchor" id="line-111"></span><p class="line874">If the initial Generator is under-specified then you will get an error saying that the system has found too many eligible Generators to begin computing a solution. <span class="anchor" id="line-112"></span>If case (1) holds then the only chance for the system to determine the correct initial Generator is if all the other Generators can be eliminated for the IC. This can never happen if there are non-state events (i.e. when case (3) holds). Artificially introduced "indicator" variables are a "trick" solution to this problem that avoids forcing terminal events to be specified in an unnatural way. A possible alternative when case (3) does not hold is to perturb the initial conditions slightly so that initial state is truly <em>inside</em> the event boundaries. <span class="anchor" id="line-113"></span><span class="anchor" id="line-114"></span><p class="line862">Indicator variables are artificial state variables (usually integers, e.g. 0 and 1) that you force to lie in a singular domain (i.e. the singleton set containing that integer), so that you get additional domain constraints without adding terminal events to your system. This information usually represents something about the system's recent history, in terms of prior terminal events. Note that although adding these variables artificially means that they are ancillary to the main variables, you should <em>not</em> make these critical indicator variables "auxiliary" variables (either explicitly using the <tt>auxvars</tt> initialization key or by omission from a <tt>vars</tt> initialization key), otherwise the values will not be tested and updated properly. However, the Model formalism has a secondary way to mark certain variables as ancillary: the <tt>forceIntVars(&lt;var_list&gt;)</tt> method labels variables as "internal", while the remaining variables are "external", i.e. <em>externally observable</em>. This will have more significance when performing Model estimation (described later). <span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span><p class="line874">In order to use an indicator variable, simply set its value as part of the initial conditions: only the Generators for which that value corresponds to the singular domain set for that Generator will match, thereby providing you sufficient conditions for determining a unique initial Generator.
<h2 id="Example">4.1. Example</h2>
<span class="anchor" id="line-119"></span><span class="anchor" id="line-120"></span><p class="line862">In <tt>PyDSTool/tests/IF_model_test.py</tt>, an integrate-and-fire neuron model with a square-pulse spike is implemented as a hybrid system with two sub-systems: 'leak' and 'spike'. A spike threshold event occurs when the variable V increases through a value of -60. The sub-threshold 'leak' ODE system is then replaced by the 'spike' explicit function system that terminates after a set duration given by the parameter 'splen'. This terminal event specification means that an initial condition cannot be placed uniquely in one of the two sub-systems. The <tt>excited</tt> variable has been introduced to record the most recent history of whether spike threshold was passed.  <span class="anchor" id="line-121"></span><span class="anchor" id="line-122"></span><p class="line874">Here is an excerpt of the specification for this model: <span class="anchor" id="line-123"></span><span class="anchor" id="line-124"></span><span class="anchor" id="line-125"></span><span class="anchor" id="line-126"></span><span class="anchor" id="line-127"></span><span class="anchor" id="line-128"></span><span class="anchor" id="line-129"></span><span class="anchor" id="line-130"></span><span class="anchor" id="line-131"></span><span class="anchor" id="line-132"></span><span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span><span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span><span class="anchor" id="line-141"></span><span class="anchor" id="line-142"></span><span class="anchor" id="line-1-1"></span><div class="highlight python"><div class="codearea" dir="ltr" lang="en"><pre dir="ltr" id="CA-e56d7e7158fdc7fec1a1880181be31d6dd879d1c" lang="en"><span class="line"><span class="anchor" id="line-1-2"></span><span class="ID">leak_args</span> = <span class="ID">args</span>(<span class="ID">name</span>=<span class="String">'</span><span class="String">leak</span><span class="String">'</span>)</span>
<span class="line"><span class="anchor" id="line-2-1"></span><span class="ID">leak_args</span>.<span class="ID">pars</span> = {<span class="String">'</span><span class="String">I</span><span class="String">'</span>: <span class="Number">1.3</span>, <span class="String">'</span><span class="String">gl</span><span class="String">'</span>: <span class="Number">0.1</span>, <span class="String">'</span><span class="String">vl</span><span class="String">'</span>: -<span class="Number">67</span>}</span>
<span class="line"><span class="anchor" id="line-3-1"></span><span class="ID">leak_args</span>.<span class="ID">xdomain</span> = {<span class="String">'</span><span class="String">V</span><span class="String">'</span>: [-<span class="Number">100</span>,<span class="Number">50</span>], <span class="String">'</span><span class="String">excited</span><span class="String">'</span>: <span class="Number">0</span>}</span>
<span class="line"><span class="anchor" id="line-4-1"></span><span class="ID">leak_args</span>.<span class="ID">varspecs</span> = {<span class="String">'</span><span class="String">V</span><span class="String">'</span>:       <span class="String">"</span><span class="String">I - gl*(V-vl)</span><span class="String">"</span>,</span>
<span class="line"><span class="anchor" id="line-5-1"></span>                      <span class="String">'</span><span class="String">excited</span><span class="String">'</span>: <span class="String">"</span><span class="String">0</span><span class="String">"</span>}</span>
<span class="line"><span class="anchor" id="line-6-1"></span><span class="ID">leak_args</span>.<span class="ID">algparams</span> = {<span class="String">'</span><span class="String">init_step</span><span class="String">'</span>: <span class="Number">0.02</span>}</span>
<span class="line"><span class="anchor" id="line-7-1"></span><span class="ID">leak_args</span>.<span class="ID">events</span> = <span class="ID">leak_thresh_ev</span></span>
<span class="line"><span class="anchor" id="line-8-1"></span><span class="ID">leak_args</span>.<span class="ID">abseps</span> = <span class="Number">1.e-7</span></span>
<span class="line"><span class="anchor" id="line-9-1"></span></span>
<span class="line"><span class="anchor" id="line-10-1"></span><span class="ID">DS_leak</span> = <span class="ID">Generator</span>.<span class="ID">Vode_ODEsystem</span>(<span class="ID">leak_args</span>)</span>
<span class="line"><span class="anchor" id="line-11-1"></span></span>
<span class="line"><span class="anchor" id="line-12-1"></span><span class="ID">spike_args</span> = <span class="ID">args</span>(<span class="ID">name</span>=<span class="String">'</span><span class="String">spike</span><span class="String">'</span>)</span>
<span class="line"><span class="anchor" id="line-13-1"></span><span class="ID">spike_args</span>.<span class="ID">tdomain</span> = [<span class="Number">0.0</span>, <span class="Number">1.5</span>]</span>
<span class="line"><span class="anchor" id="line-14-1"></span><span class="ID">spike_args</span>.<span class="ID">varspecs</span> = {<span class="String">'</span><span class="String">V</span><span class="String">'</span>: <span class="String">"</span><span class="String">if(t&lt;splen,50,-95)</span><span class="String">"</span>, <span class="String">'</span><span class="String">excited</span><span class="String">'</span>: <span class="String">"</span><span class="String">1</span><span class="String">"</span>}</span>
<span class="line"><span class="anchor" id="line-15-1"></span><span class="ID">spike_args</span>.<span class="ID">pars</span> = {<span class="String">'</span><span class="String">splen</span><span class="String">'</span>: <span class="Number">0.75</span>}</span>
<span class="line"><span class="anchor" id="line-16-1"></span><span class="ID">spike_args</span>.<span class="ID">xdomain</span> = {<span class="String">'</span><span class="String">V</span><span class="String">'</span>: [-<span class="Number">97</span>, <span class="Number">51</span>], <span class="String">'</span><span class="String">excited</span><span class="String">'</span>: <span class="Number">1</span>}</span>
<span class="line"><span class="anchor" id="line-17-1"></span></span>
<span class="line"><span class="anchor" id="line-18-1"></span><span class="ID">DS_spike</span> = <span class="ID">Generator</span>.<span class="ID">ExplicitFnGen</span>(<span class="ID">spike_args</span>)</span>
</pre></div></div><span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><p class="line862">Here, the <tt>excited</tt> variable is set to exist in the singleton domain {0} for the leak phase, and {<tt class="backtick"></tt>1} for the spike phase. The initial condition <tt>icdict&nbsp;=&nbsp;{'V':&nbsp;-80.,&nbsp;'excited':&nbsp;0}&nbsp;</tt> will only satisfy the domain test for the <tt>excited</tt> variable in the leak phase. <span class="anchor" id="line-145"></span><span class="anchor" id="line-146"></span><p class="line862">An example of case (2) occurs in <tt>PyDSTool/tests/SLIP2D.py</tt>, in which a spring loaded inverted pendulum model of a leg in 2D is implemented. The hybrid model consists of two phases, a 'stance' and a 'flight' phase. The flight phase is entered when the leg reaches full extension (zeta=1). The initial velocities of the state variables in the file are pointing upwards, but the events are only given in terms of position variables. It is also natural to specify an IC for the system where zeta=1, which is on the event boundary for the stance phase Generator. So while it is intuitively obvious that the flight phase should be the initial Generator in this situation, the problem is formally underspecified. A very small number could be added to the position variables such that zeta would be microscopically greater than 1, but this is inelegant. The hybrid solver can resolve the situation if a variable <tt>incontact</tt> is introduced. This is implemented almost identically to the <tt>excited</tt> variable in the Integrate-and-Fire model. <span class="anchor" id="line-147"></span>
<h2 id="Some_event_consistency_checking_comes_for_free">4.2. Some event consistency checking comes for free</h2>
<span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span>
<p class="line874">If you make a mistake in the setting up of the events, such that a given IC does not meet any of the pre-terminal event criteria specified, then you will get an error saying that there were no Generators eligible for beginning the trajectory computation. <span class="anchor" id="line-152"></span><span class="anchor" id="line-153"></span><span class="anchor" id="line-154"></span>Using a higher level of verbosity in the call to 'compute' will provide more information about which tests failed.<p class="line867">
<h1 id="Hybrid_systems_with_only_one_vector_field">5. Hybrid systems with only one vector field</h1>
<span class="anchor" id="line-155"></span><span class="anchor" id="line-156"></span><p class="line874">Some hybrid systems involve a single vector field with events that cause discrete state changes. In PyDSTool such events are implemented as terminal events that have associated state mappings to make the discrete changes. These events must either point back to the same vector field (using the associated Generator's name) or the name 'terminate' to end the trajectory solution altogether. <span class="anchor" id="line-157"></span><span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span><p class="line867">
<h1 id="Using_hybrid_systems_to_mix_maps.2C_preset_trajectories.2C_and_ODEs">6. Using hybrid systems to mix maps, preset trajectories, and ODEs</h1>
<span class="anchor" id="line-160"></span><span class="anchor" id="line-161"></span><p class="line862">The event transition functions of a hybrid system Model object can be used to represent sophisticated forms of mapping that can be interspersed with ODE vector fields. By the flexible class hierarchy of Generators, a mixture of types of Generator can be present in a hybrid system. For instance, part of a vector field can be specified by an ODE, and another by a preset time-course (e.g., using an <tt>InterpolateTable</tt> Generator), such as that in <tt>/tests/IF_squarespike_model.py</tt>, in which a threshold event in an ODE model of an excitable medium triggers a "square-pulse" spike of pre-determined duration to occur, before returning control over the trajectory computation to the ODE. <span class="anchor" id="line-162"></span><span class="anchor" id="line-163"></span><p class="line867">
<h2 id="Using_hybrid_systems_to_implement_discrete_delays">6.1. Using hybrid systems to implement discrete delays</h2>
<span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span><p class="line874">One application of event manipulation by transition functions is to implement a form of discrete delay in the coupling between ODE variables. This is currently in development, and so is not a feature that is easy to use. <span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><p class="line862">The delay of an event can be used to effectively implement discretely-delayed dirac delta function pulses (where the pulses correspond to discrete events). For instance, see the delta-function pulse-coupling between "integrate-and-fire" neurons in <tt>/tests/IF_delaynet.py</tt>. Note that the <em>effect</em> of the pulse (event) need not merely be an instantaneous change in state. The event can be used to trigger longer-lasting changes in state (e.g. see <tt>/tests/IF_delaynet_syn.py</tt>). <span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><span class="anchor" id="line-170"></span><p class="line867">

<h1 id="Using_hybrid_systems_to_represent_numerically-computed_maps">7. Using hybrid systems to represent numerically-computed maps</h1>

<p class="line862">Consider the example of a 2D spring-loaded inverted pendulum (SLIP) model of a leg in <tt>/tests/SLIP_2D_maps.py</tt>. This particular mechanical model has an <em>unstable</em> limit cycle, which is identified using a simple shooting method and a SciPy wrapper around Minpack routines in <tt>/tests/SLIP_2D_pdc.py</tt>. Of interest in the analysis of this model is the map from one foot-fall impact to the next, which in general can only be computed numerically. However, the power of dynamic typing and the interactive nature of Python means that a Python function can be written that behaves exactly like the required mapping, although in fact it involves a numerical integration of the hybrid system until the appropriate event occurs. <span class="anchor" id="line-173"></span><span class="anchor" id="line-174"></span><p class="line874">This is an example of the power of Python's dynamic typing and the PyDSTool classes in order to embed numerical algorithms inside each other. <span class="anchor" id="line-175"></span><span class="anchor" id="bottom"></span></div>

<div id="pagebottom"></div>
</div>
</body>
</html>

